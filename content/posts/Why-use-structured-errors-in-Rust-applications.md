+++
title = 'Why Use Structured Errors in Rust Applications?'
tags = ['error handling', 'tech']
date = 2025-05-28
lastmod = 2025-05-30
draft = false
summary = 'Going against the common wisdom of "using `anyhow` for applications".'
+++

TL;DR I prefer `thiserror` enums over `anyhow`, even for application code that
simply propagates errors. Custom error types require additional effort, but make
the code easier to reason about and maintain down the road.

## "Using `thiserror` for libraries and `anyhow` for applications"

In 2025, this is the conventional error handling practice in the Rust community.
Let's quickly recap the main ideas:

- Libraries should expose error types that provide as much information as
  possible. This allows the callers to detect and handle specific error
  conditions. A specific error code is more useful than "Oops, something went
  wrong". Structured [^structured] error types facilitate statically-checked
  pattern matching, which is more reliable than runtime reflection, downcasting,
  or regex-matching an error message. They also provide nice autogenerated docs,
  which is very important for libraries.
- Unfortunately, propagating structured errors in Rust is associated with the
  boilerplate of manually writing out wrapper error types, their `impl`s and
  conversions. [^nominal]
- [`thiserror`](https://github.com/dtolnay/thiserror) removes the boilerplate
  around implementing
  [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html),
  [`Error`](https://doc.rust-lang.org/std/error/trait.Error.html) and
  [`From`](https://doc.rust-lang.org/std/convert/trait.From.html) for your error
  types. Using it is a no-brainer for libraries that can "afford" proc macro
  dependencies. Although, you still need to define and annotate the wrapper
  types themselves, which there are usually plenty.
- End applications often don't care about the specific cause of an error and
  simply propagate errors up the stack until they reach some kind of a
  "catch-all" point. For this use case, even `thiserror`-assisted error types
  are often considered too cumbersome and not worth it.
- Instead, application developers commonly use
  [`anyhow`](https://github.com/dtolnay/anyhow). It provides a "universal"
  dynamic error type, along with helper methods that make dealing with it even
  easier than returning a string. [^error-string]

If you google "error handling in Rust", the typical introductory posts are going
to start with the basics of `panic`, `Option` and `Result`, then explain these
two libraries, give this rule of thumb to choose bethween them, show some code,
and stop right here.

## Pattern matching isn't the only reason to use structured errors

At work, my team has written a ~50k LoC web server in Rust. We've been
maintaining it full-time for over a year. It mostly follows the same pattern of
"just propagate the error" and almost never pattern-matches specific error
conditions. The main benefit of structured errors is not applicable. It sounds
like we should be using something like `anyhow` instead of spending time on
maintaining our own error types. But I found many other benefits of doing so:

- Custom error types allow you to see all potential failure modes of a function
  at a glance, without (recursively) inspecting its implementation or
  maintaining fragile hand-written docs that can't be fully trusted anyway. In a
  code review, you can easily notice when some error variant doesn't make sense
  and should be handled locally, or comes from an action that shouldn't be
  performed at all. Interfaces become more descriptive.
- When the error type is narrow and descriptive enough, you can understand the
  function just by looking at its signature, without even going to the error
  definition:
  ```rust
  fn foo(..) -> Result<.., TheOnlyPossibleFailure>
  ```
- You don't repeat yourself when the same error is thrown from multiple places.
  Each error message is specified once when you define the type
  [^message-in-display]. This results in a more consistent user experience, as
  well as better developer experience. Now your domain errors have IDE
  integration, with operations like "find references" and so on.
- The logic is less littered with error messages or adding context.
  `return Err(MyType)`, `?` or `map_err` are usually more compact than full
  error text formatting. There may be more code overall, but the error-related
  code is moved "out of the way" to the type definition.
- Although `anyhow` provides convenience methods for adding context to errors,
  in practice it's easy to forget, and `?` works happily without context. I had
  to debug such cases multiple times. In contrast, `thiserror` derive forces you
  to think about this, because you have to explicitly put *something* in the
  `#[error(...)]` annotation. Even if you roll with `#[error(transparent)]` (no
  context), that's now an explicit choice that can be questioned in a code
  review, etc.
- Custom error types can be enriched with additional data and
  functionality[^theoretical-impls]:
    - You can slap on
      [`#[derive(Serialize)]`](https://docs.rs/serde/1.0.219/serde/trait.Serialize.html)
      to log/return nested JSON data along with an error.
    - You can implement
      [`std::process::Termination`](https://doc.rust-lang.org/stable/std/process/trait.Termination.html)
      to give your error an associated
      [ExitCode](https://doc.rust-lang.org/stable/std/process/struct.ExitCode.html).
    - You can implement
      [`axum::IntoResponse`](https://docs.rs/axum/0.8.1/axum/response/trait.IntoResponse.html)
      to give your error an associated [HTTP status
      code](https://docs.rs/http/1.2.0/http/response/struct.Response.html#method.status).
    - You can implement something like this to have localized error messages:
      ```rust
      trait Localize {
          fn localize(&self, language: Language) -> String;
      }
      ```

## The tradeoffs

Custom errors have their drawbacks:

- It's more code and more types [^more-types].
- To combat the boilerplate, you usually introduce a third-party dependency like
  `thiserror`. [^raw-dyn-is-easier]
- You need to put thought into structuring the code, because otherwise no one
  will find and reuse your existing error types.
- You need to come up with names for error types and enum variants. These names
  may not be as clear as full error messages. So, in order to understand the
  code, you may end up jumping to the message anyway. I
  [requested](https://github.com/rust-lang/rust-analyzer/issues/16945) a feature
  in `rust-analyzer` that would allow previewing `#[error(..)]` attributes
  without jumping away from the code that I'm working on.
- You also need to maintain these names as the codebase evolves! In my team, we
  often forgot to update the type/variant name when updating an error message.
- You have to maintain the error types as your functions begin or stop returning
  certain error variants. This adds maintainance overhead, but can be seen as an
  advantage (see the points about code reviews, descriptive interfaces,
  enforcing context on errors). I see a parallel with adding/removing `Result`
  from the signature, which is widely considered a "necessary evil".
- If your error is in a separate file, you jump back-and-forth between the files
  when coding. [^error-placement]
- If an error enum is public in its crate, the compiler doesn't warn about
  unused variants. This means that sometimes unused variants may accumulate and
  you need to manually notice and trim them. [^tooling-issue]
- If you want your errors to include a backtrace, you need to explicitly add a
  [`Backtrace`](https://doc.rust-lang.org/std/backtrace/struct.Backtrace.html)
  field. [^dont-need-backtraces]

If your application is performance-sensitive, there are also performance
considerations that don't present a clear winner:

- Should your errors be cheap to create? Are your errors frequently discarded
  without ever being displayed? Are your errors displayed multiple times? Do you
  need a backtrace? Currently, the contents of `anyhow::Error` are
  heap-allocated, the arguments to `anyhow!` are [eagerly
  formatted](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=41af825d68e5b1d7bafdbaa9d768787d),
  and a
  [backtrace](https://docs.rs/anyhow/1.0.95/anyhow/struct.Error.html#method.backtrace)
  may be captured depending on environment variables[^backtrace-issues]. Typical
  custom errors avoid allocations, are lazily formatted, and don't capture a
  backtrace. But you can change all of that.
- Should your errors be small and cheap to propagate? Currently, `anyhow::Error`
  is always a single pointer, while custom errors range from
  [zero-sized](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)
  unit structs to large collections of values that are waiting to be formatted.
  You may need to box and/or preformat your custom errors.

Custom errors can even have surprising downsides in libraries (e.g.,
[semver-related](https://www.reddit.com/r/rust/comments/1kx0ak8/why_use_structured_errors_in_rust_applications/muvblzn/)).
But I don't duscuss libraries today!

Assessing the tradeoff is up to you. Structured errors are worth it in my
application.

## To be continued

To present the full picture, I also wanted to cover:

- How to actually manage your custom error types to maximize the benefits and
  minimize the maintenance cost.
- A concrete example of error types helping me reason about the requirements in
  my application.

But this saga takes too long, so these topics go to their own separate posts and
this post ends here. ðŸš§

I have to be *âœ¨ agile âœ¨* in order to actually publish anything.

---

## Related reading

Check out my first post about error handling:

- [Rust Solves The Issues With Exceptions]({{< ref
"/posts/rust-solves-the-issues-with-exceptions/" >}})

I've also found these good posts about structured errors in Go and Haskell, but
they're quite detailed and the actual approach in the code is quite different
from mine:

- [Structured errors in Go](https://southcla.ws/structured-errors-in-go)
- [Structure your Errors](https://jelv.is/blog/Structure-your-Errors/)

I'll discuss mine in the next post in the series.

## Discuss

- [{{< icon "reddit" >}}
  r/rust](https://www.reddit.com/r/rust/comments/1kx0ak8/why_use_structured_errors_in_rust_applications/?)

[^structured]: "Structured errors" = non-opaque, non-string error types. Types
that have a "shape".

[^nominal]: This is caused by having a [nominal type
system](https://en.wikipedia.org/wiki/Nominal_type_system) in general and
lacking [anonymous unions](https://github.com/rust-lang/rfcs/issues/294) in
particular.

[^error-string]: Returning an error string is a common pattern among beginners,
because it's very easy to understand and use. `anyhow` retains the same
advantages while also supporting richer features like backtraces, error
chaining and automatic conversions from library error types.

[^message-in-display]: Actually, error messages are specified in the `Display`
impl, rather than the type itself. But when using `thiserror`, the error
messages appear as annotations on the type.

[^theoretical-impls]: While most of this post comes from my real experience, the
examples in this list are theoretical. I've never actually implemented these
features. Please call me out if something's wrong with this section. Also, send
concrete examples, if you know any!

[^more-types]: IMO, it's totally worth it, because these types replace
hand-written docs that list the possible errors. Type-checked docs are the best!

[^raw-dyn-is-easier]: For dynamic errors, you usually introduce an
`anyhow`-style dependency too. But if you want to avoid dependencies, then
living with raw `Box<dyn Error>` is probably easier than hand-writing impls for
all your custom types.

[^error-placement]: I rarely hit this issue in practice, because I try to keep
my error types local to the function. I'll discuss the factoring and placement
of error types in the next post in the series.

[^tooling-issue]: Just like with the point about "jumping to the error message",
one can argue that this is just a limitation of our current tooling, rather than
a fundamental flaw of custom enums.

[^dont-need-backtraces]: I've never needed backtraces in my own errors, because
good error messages with enough context are
[enough](https://www.reddit.com/r/rust/comments/1kx0ak8/why_use_structured_errors_in_rust_applications/muoj5io/)
to debug and reproduce the issue. And custom errors encourage thinking about
context messages. Both you and your users benefit from this.

[^backtrace-issues]: Currently, capturing backtraces is expensive. See
[backtrace-related
issues](https://github.com/dtolnay/anyhow/issues?q=is%3Aissue%20state%3Aopen%20backtrace)
in the `anyhow` repo.
